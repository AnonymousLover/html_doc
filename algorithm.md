> 算法知识点

### 基本知识
* 时间复杂度 --时间复杂度是指执行算法所需要的计算工作量。
    ```
    重点在其计算方法：
        一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f（n），因此，算法的时间复杂度记做：T（n）=O（f（n））。 在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出T（n）的同数量级（它的同数量级有以下：1，Log2n ，n ，nLog2n ，n的平方，n的三次方，2的n次方，n！），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度T（n）=O（f（n））。
    在pascal中比较容易理解，容易计算的方法是：看看有几重for循环，只有一重则时间复杂度为O（n）,二重则为O（n^2），依此类推，如果有二分则为O(logn)，二分例如快速幂、二分查找，如果一个for循环套一个二分，那么时间复杂度则为O(nlogn)。归并排序就是这样一种情况。
    ```
* 空间复杂度
    ```
    空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度,记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了,因为每次递归都要存储返回信息。
    一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。
    Ex： 递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表示开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。
    ```

#### 长递增子序列详解（longest increasing subsequence）
对于动态规划问题，往往存在递推解决方法，这个问题也不例外。要求长度为i的序列的Ai{a1,a2,……,ai}最长递增子序列，需要先求出序列Ai-1{a1,a2,……,ai-1}中以各元素(a1,a2,……,ai-1)作为最大元素的最长递增序列，然后把所有这些递增序列与ai比较，如果某个长度为m序列的末尾元素aj(j<i)比ai要小，则将元素ai加入这个递增子序列，得到一个新的长度为m+1的新序列，否则其长度不变，将处理后的所有i个序列的长度进行比较，其中最长的序列就是所求的最长递增子序列。举例说明，对于序列A{35, 36, 39, 3, 15, 27, 6, 42}当处理到第九个元素(27)时，以35， 36， 39， 3， 15， 27， 6为最末元素的最长递增序列分别为
```   
    35
    35，36
    35，36，39
    3
    3，15
    3，15，27
    3，6
```
当新加入第10个元素42时，这些序列变为
```   
    35，42
    35，36，42
    35，36，39，42，
    3，42
    3，15，42
    3，15，27，42
    3，6，42
```
这其中最长的递增序列为(35，36，39，42)和(3，15，27，42)，所以序列A的最长递增子序列的长度为4，同时在A中长度为4的递增子序列不止一个。
该算法的思想十分简单，如果要得出Ai序列的最长递增子序列，就需要计算出Ai-1的所有元素作为最大元素的最长递增序列，依次递推Ai-2，Ai-3，……，将此过程倒过来，即可得到递推算法，依次推出A1，A2，……，直到推出Ai为止，

在基本算法中，我们发现，当需要计算前i个元素的最长递增子序列时，前i-1个元素作为最大元素的各递增序列，无论是长度，还是最大元素值，都毫无规律可循，所以开始计算前i个元素的时候只能遍历前i-1个元素，来找到满足条件的j值，使得aj < ai，且在所有满足条件的j中，以aj作为最大元素的递增子序列最长。有没有更高效的方法，找到这样的元素aj呢，实际是有的，但是需要用到一个新概念。在之前我举的序列例子中，我们会发现，当计算到第10个元素时，前9个元素所形成最长子序列分别为
```   
    35
    35，36
    35，36，39
    3
    3，15
    3，15，27
    3，6
```
这其中长度为3的子序列有两个，长度为2的子序列有3个，长度为1的子序列2个，所以一个序列，长度为n的递增子序列可能不止一个，但是所有长度为n的子序列中，有一个子序列是比较特殊的，那就是最大元素最小的递增子序列（挺拗口的概念），在上述例子中，序列(3)，(3,6)，(3，5，27)就满足这样的性质，他们分别是长度为1，2，3的递增子序列中最大元素最小的（截止至处理第10个元素之前），随着元素的不断加入，满足条件的子序列会不断变化。如果将这些子序列按照长度由短到长排列，将他们的最大元素放在一起，形成新序列B{b1,b2,……bj}，则序列B满足b1 < b2 < …… <bj。这个关系比较容易说明，假设bxy表示序列A中长度为x的递增序列中的第y个元素，显然，如果在序列B中存在元素bmm > bnn，且m < n则说明子序列Bn的最大元素小于Bm的最大元素，因为序列是严格递增的，所以在递增序列Bn中存在元素bnm < bnn，且从bn0到bnm形成了一个新的长度为m的递增序列，因为bmm > bnn，所以bmm > bnm，这就说明在序列B中还存在一个长度为m，最大元素为bnm < bmm的递增子序列，这与序列的定义，bmm是所有长度为m的递增序列中第m个元素最小的序列不符，所以序列B中的各元素严格递增。发现了如此的一个严格递增的序列，这让我们柳暗花明，可以利用此序列的严格递增性，利用二分查找，找到最大元素刚好小于aj的元素bk，将aj加入这个序列尾部，形成长度为k+1但是最大元素又小于bk+1的新序列，取代之前的bk+1，如果aj比Bn中的所有元素都要大，说明发现了以aj为最大元素，长度为n+1的递增序列，将aj做Bn+1的第n+1个元素。从b1依次递推，就可以在O(nlogn)的时间内找出序列A的最长递增子序列。
理论说明比较枯燥，来看一个例子，以序列{6，7，8，9，10，1，2，3，4，5，6}来说明改进算法的步骤：
程序开始时，最长递增序列长度为1（每个元素都是一个长度为1的递增序列），当处理第2个元素时发现7比最长递增序列6的最大元素还要大，所以将6，7结合生成长度为2的递增序列，说明已经发现了长度为2的递增序列，依次处理，到第5个元素(10)，这一过程中B数组的变化过程是
```   
    6
    6，7
    6，7，8
    6，7，8，9
    6，7，8，9，10
```
开始处理第6个元素是1，查找比1大的最小元素，发现是长度为1的子序列的最大元素6，说明1是最大元素更小的长度为1的递增序列，用1替换6，形成新数组1，7，8，9，10。然后查找比第7个元素(2)大的最小元素，发现7，说明存在长度为2的序列，其末元素2，比7更小，用2替换7，依次执行，直到所有元素处理完毕，生成新的数组1，2，3，4，5，最后将6加入B数组，形成长度为6的最长递增子序列.
这一过程中，B数组的变化过程是
```
    1，7，8，9，10
    1，2，8，9，10
    1，2，3，9，10
    1，2，3，4，10
    1，2，3，4，5
    1，2，3，4，5，6
```
当处理第10个元素(5)时，传统算法需要查看9个元素(6,7,8,9,10,1,2,3,4)，而改进算法只需要用二分查找数组B中的两个元素(3, 4)，可见改进算法还是很阴霸的。

这个算法的思想可以算得上巧妙，在时间复杂度上提升明显，但是同时在实现时也比通俗算法多了好些坑，这里说明一下：
* 算法中为了获得实际的序列，数组B中保存的不是长度为j的递增序列的最大元素的最小值，而是该值在输入数组A中的位置，如果只想求出最长递增子序列的长度，则B数组可以直接保存满足条件元素的值
* 二分查找的结果，我们的目的是找到这样的一个j，使满足A[B[j]] > A[i]的所有j中，j取得最小值，但是在二分查找的时候可能会发生两种特殊情况，B数组的所有元素都不小于A[i]，B数组的所有元素都比A[i]小，对于这两中情况需要专门处理
* 对于B中所有元素都不小于A[i]的情况，要将A[i]更新到B[0]的位置
* 对于B中所有元素都小于A[i]的情况，要将更新到B[max]的位置，同时将max值增加1，说明找到了比当前最长的递增序列更长的结果
* 对于其他情况，在更新新节点的前驱节点时，要注意，当前元素的前驱节点是B[j-1]，而不是pre[B[j]]，这点要格外留意，后者看似有道理，但实际上在之前的更新中可能已经被变更过。
性能比较：长度为5000的随机数组，在我的机器上，改进算法的速度提升将近200倍，可见算法改进在程序性能表现中的重要性。不过传统算法也并非毫无价值，
首先，传统算法可以用来验证改进算法的正确性。二分搜索中的不确定性还是相当让人头痛的。其次，如果要求最长非递减子序列，最长递减子序列等等，传统算法改起来非常的直观（已经注释说明），而改进算法，最起码我没有一眼看出来如何一下就能改好。


**question:**
- 对于一个序列A，最长递增子序列可能不止一个，传统算法找到的是所有递增子序列中，最大值下标最小（最早出现）的递增子序列，而改进算法找到的是最大值最小的递增子序列，那么改进算法所找到的递增子序列，是不是所有最长递增子序列中各元素合最小的一个呢，我感觉很可能是，但是还没想出怎么证明。
- 对于元素互不相同的随机数序列A，他的最长递增子序列的数学期望是多少呢？